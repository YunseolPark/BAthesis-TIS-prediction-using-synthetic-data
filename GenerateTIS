"""
May 1, 2020
"""

"""
This python script generates a synthetic TIS dataset for training a prediction model.
It makes use of consensus sequence, upstream start codon, downstream stop codon, and nucleotide frequency to generate the dataset.
It takes a file containing the position weight matrix (pwm).
It creates two files as outputs, each containing the positive and negative samples.
"""


#This function reads the file containing the pwm and outputs a dictionary containing the weights
#   It also takes a length 'l' which indicates the length of the consensus sequence (deafault: 20)
#   It will create a dictionary that has positions as key and a list of weights as item
def readConsensus(file,l):

    l = int(l/2)
    #Get a list of the position of consensus
    #   Exclude the TIS site
    #   To be used to insert the consensus into the write position
    position = [j for j in range(-l, l + 3) if j not in [0, 1, 2]]
    #print(position)

    #Make an empty list and counter
    #   cons will have each row into a list
    #   count will check that the file has 4 rows
    cons = []
    count = 0
    for row in open(file, 'r').readlines():
        cons += [row.split(' ')]
        count += 1

    assert count == 4, 'There should be 4 rows, one for each nucleotide'

    #This section sees how the pwm is ordered.
    #   It will give a number for each nucleotide so that the values from the pwm match the correct nucleotide
    #Each nucleotide is ordered as seen (from 0-3)
    A,C,G,T = 0,1,2,3
    order = []
    #In the list 'order' numbers 0-3, which indicate for a nucleotide each, will be inserted according to the order of pwm
    for nuc in range(0,4):
        if cons[nuc][0] == 'A':
            order.append(A)
        elif cons[nuc][0] == 'C':
            order.append(C)
        elif cons[nuc][0] == 'G':
            order.append(G)
        elif cons[nuc][0] == 'T':
            order.append(T)

    #Ordered consensus sequence with rows A,C,G,T
    cons = [cons[i] for i in order]
    #Dictionary for the consensus sequence
    consensus = dict()
    #A loop along the length of consensus
    for k in range(1, l*2+1):
        nucleotide = []
        for seq in cons:
            nucleotide.append(float(seq[k]))
        #Add the weights from each row on the same column to the position of the weights
        consensus[position[k-1]] = nucleotide

    return consensus


#form basic structure, distinguishes upstream and downstream with ATG in middle
#takes in the start codon and a certain length (len(seq) = length*2+3)
def BasicStructure(start, length):

    seq = []
    seq += 'u' * length
    seq += start
    seq += 'd' * length

    #print(seq)
    #print("".join(i for i in seq))
    return seq


def PWMtoBase(A,C,G,T):

    import random

    total = A+C+G+T

    prob = random.randint(1,total)
    if prob <= A:
        return 'A'
    elif prob > A and prob <= A+C:
        return 'C'
    elif prob > A+T and prob <= A+C+G:
        return 'G'
    else:
        return 'T'


#adds consensus sequence around ATG
#takes length, sequence, and a dictionary with probabilities
def ConsensusSequence(length, seq, conFile, l):

    consensus = readConsensus(conFile, l)

    #keys span from negative to positive number, with ATG being 0,1,2
    for i in consensus.keys():
        seq[length+i] = PWMtoBase(consensus[i][0],consensus[i][1],consensus[i][2],consensus[i][3])

    #print(seq)
    #print("".join(i for i in seq)+"hey?")
    return seq


#Add the upstream start codon
#takes in start codon, length, sequence, length of upstream consensus sequence
#train indicates whether dataset is positive or negative
def UpstreamStart(start, length, seq, l):

    import random

    n = random.choices([0,1], [60,40])[0]
    if n == 1:
        n = random.randint(1,2)

    #print(n)
    in_len = int(length/3)
    #only add start codons upstream of consensus sequence
    in_len -= int((l+2)/3)
    #select a random position to insert start codon
    if n == 1:
        pos1 = random.randint(0, in_len-3)
        seq[pos1*3:pos1*3+3] = start
    elif n == 2:
        pos1 = random.randint(0, in_len-6)
        pos2 = random.randint(pos1 + 3, in_len-3)
        seq[pos1*3:pos1*3+3] = start
        seq[pos2*3:pos2*3+3] = start

    #print(seq)
    #print("".join(i for i in seq))
    return seq


#add downstream stop codon for negatvie datasets
#takes in list of stop codons, length, sequence, and length of downstream consensus
def DownstreamStop(stop_list, length, seq, l):

    import random

    #select a random stop codon
    stop = random.choice(stop_list)
    #select random position for stop codon
    in_len = int(length/3)

    stop_site = random.randint(in_len+int((l+2)/3), in_len*2)
    seq[stop_site*3:stop_site*3+3] = stop

    #print(seq)
    #print("".join(i for i in seq))
    return seq


#fill all the other bases
#takes in length, sequence, and 'neg'/'pos'
def Fill(length, seq, train):

    import random

    #negative training set
    if train == 'neg':
        for i in range(0,len(seq)):
            if seq[i] in ['A','C','G','T']:
                continue
            #if the base isn't filled already, fill with probability
            #for neg, upstream and downstream are same (translated)
            seq[i] = PWMtoBase(27.60,21.06,24.86,26.48)

        #print(seq)
        #print("".join(i for i in seq))
        return seq

    #for positive dataset
    #use different probability for upstream and downstream
    for up in range(0, length):
        if seq[up] != 'u':
            continue
        seq[up] = PWMtoBase(29.32,18.44,16.51,35.73)

    for down in range(length+3, len(seq)):
        if seq[down] != 'd':
            continue
        seq[down] = PWMtoBase(27.60,21.06,24.86,26.48)

    #print(seq)
    #print("".join(i for i in seq))
    return seq


#generate tis
def Generate(train, length, conFile, l):

    start = ['A','T','G']
    stop_list = [['T', 'A', 'A'], ['T', 'A', 'G'], ['T', 'G', 'A']]

    #generate the sequence
    seq = BasicStructure(start, length)
    if train == 'pos':
        seq = ConsensusSequence(length, seq, conFile, l)
        seq = UpstreamStart(start, length, seq, l)
    if train == 'neg':
        seq = DownstreamStop(stop_list, length, seq, l)
    seq = Fill(length, seq, train)

    #seq = "".join(i for i in seq)

    return seq


#write generated TIS in text file
def WriteTIS(rows, conFile, posFile, negFile, length=150, l=20):

    assert length%3==0, 'length must be a multiplier of 3'

    tis_pos = open(posFile, "w+")
    tis_neg = open(negFile, "w+")

    stop_list = ['TAA', 'TAG', 'TGA']

    for i in range(0, rows):
        positive = "".join(i for i in Generate('pos',length,conFile,l))
        negative = "".join(j for j in Generate('neg',length,conFile,l))

        position_pos = []
        for p in range(0, len(positive), 3):
            if p < length and positive[p:p + 3] == "ATG":
                position_pos.append(p)
            elif p >= length+3 and positive[p:p + 3] in stop_list:
                #print(positive[p:p + 3])
                positive = positive[:p] + PWMtoBase(27.60, 21.06, 24.86, 26.48) \
                           + PWMtoBase(27.60, 21.06, 24.86, 26.48) \
                           + PWMtoBase(27.60, 21.06, 24.86, 26.48) + positive[p + 3:]

        while len(position_pos) > 2:
            positive = positive[:position_pos[0]] + PWMtoBase(27.60, 21.06, 24.86, 26.48) \
                       + PWMtoBase(27.60, 21.06, 24.86, 26.48) \
                       + PWMtoBase(27.60, 21.06, 24.86, 26.48) \
                       + positive[position_pos[0] + 3:]
            #print(position_pos)
            position_pos.pop(0)

        tis_pos.write(positive+'\n')
        tis_neg.write(negative+'\n')

    tis_pos.close()
    tis_neg.close()


#Generate('pos')
#Generate('neg')
WriteTIS(25000,'consensus.txt','arab_TIS.pos','arab_TIS.neg',150,20)
#check()
